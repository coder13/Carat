#!/usr/bin/env node
'use strict';

const yargs = require('yargs')
	.usage('Usage: carat <file> [options]')
    .describe('r', 'Recursive flag. Will recursively check required files. Default is false.')
    .describe('s', 'Sink flag. Will list all the sinks in the program.')
    .describe('v', 'Verbose flag. Will print all statements. Default is false.')
    .describe('d', 'debug flag. Will output the file and line of the code being checked when an error is thrown')
    .alias('d', 'debug')
    .help('h')
    .alias('h', 'help')
    .showHelpOnFail(false);

const carat = require('../lib');
const check = carat.check;
const query = carat.query;
const utils = require('../lib/utils');

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

const args = yargs.argv;

const options = {
	recursive: !!args.r,
	debug: !!args.d,
	verbose: !!args.v,
	pretty: !!args.p,
	sinks: !!args.s,
	json: !!args.j
};

var find = function (file) {
	if (!fs.existsSync(file)) {
		console.error(file, 'doesn\'t exist.');
		return false;
	} else if (!fs.lstatSync(file).isFile()) {
		let pkgJson = require(file + '/package.json');
		if (pkgJson.main) {
			file += '/' + pkgJson.main;
		} else {
			file += '/index.js';
		}

		if (!fs.existsSync(file)) {
			console.error(file, 'doesn\'t exist.');
			return false;
		} else if (!fs.lstatSync(file).isFile()) {
			console.error(file, 'is a directory.');
			return false;
		}
	}
	return file;
};

let exitCode = 0;

args._.map(file => path.resolve(file)).forEach(function (file) {
	file = find(file);
	if (!file) {
		return;
	}

	var code = fs.readFileSync(file);
	if (code) {
		options.file = file;

		let reports = [];

		console.log(chalk.yellow('-------------'), file);

		let ast = utils.getAst(String(code));
		let checked = check(options, ast, function (scope, node) {
			var report = query(scope, node, function (report) {
				if (!options.json && report) {
					console.log(chalk.red('vuln:'), report);
					// reports.push(report);
				}
			});
		});

		if (options.json) {
			var out = {};
			if (checked.reports) {
				out.Reports = checked.reports;
			}
			// if (checked.reportedSinks && checked.reportedSinks.length != 0) {
			// 	out.ReportedSinks = checked.reportedSinks;
			// }
			console.log(JSON.stringify(out));
		} else {
			// if (sinks && sinks.length != 0) {
			// 	console.log(require('prettyjson').render({'Sinks': sinks}));
			// }
			if (reports && reports.length !== 0) {
				console.log(require('prettyjson').render({'Reports': reports}));
			} else {
				console.log(chalk.green('No vulneralbilities found'));
			}
		}

		if (!exitCode) {
			exitCode = reports.length > 1 ? 1 : 0;
		}
	}
});

process.exit(exitCode);
